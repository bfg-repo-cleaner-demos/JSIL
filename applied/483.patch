From b6fda4732fd9210f678dfd0ab126f6bd1a472415 Mon Sep 17 00:00:00 2001
From: ik <igor@kiselev.spb.ru>
Date: Tue, 13 May 2014 02:13:40 -0700
Subject: [PATCH] Added closed generic method info, implemented
 MakeGenericMethod. Added possiblity to Invoke closed generic through
 reflection. Test added.

--HG--
extra : source : e5a4c33dd8b62bb49cfde120631f7da1d3c85e8e
---
 Libraries/JSIL.Bootstrap.js                        |   2 +-
 Libraries/JSIL.Core.Reflection.js                  |  41 ++++++-
 Libraries/JSIL.Core.js                             |  15 ++-
 .../ReflectionGenericMethodInvoke.cs               | 135 +++++++++++++++++++++
 Tests/Tests.csproj                                 |   1 +
 5 files changed, 188 insertions(+), 6 deletions(-)
 create mode 100644 Tests/SimpleTestCases/ReflectionGenericMethodInvoke.cs

diff --git a/Libraries/JSIL.Bootstrap.js b/Libraries/JSIL.Bootstrap.js
index c25684b..56fb3be 100644
--- a/Libraries/JSIL.Bootstrap.js
+++ b/Libraries/JSIL.Bootstrap.js
@@ -386,7 +386,7 @@ JSIL.ImplementExternals("System.Delegate", function ($) {
           $jsilcore.TypeRef("System.Reflection.MethodInfo")
         ], [])), 
     function CreateDelegate (delegateType, firstArgument, method) {
-      var impl = JSIL.$GetMethodImplementation(method);
+      var impl = JSIL.$GetMethodImplementation(method, firstArgument);
 
       var delegatePublicInterface = delegateType.__PublicInterface__;
 
diff --git a/Libraries/JSIL.Core.Reflection.js b/Libraries/JSIL.Core.Reflection.js
index 27e0b3c..e86effa 100644
--- a/Libraries/JSIL.Core.Reflection.js
+++ b/Libraries/JSIL.Core.Reflection.js
@@ -812,7 +812,7 @@ JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) {
   $.Method({Static:false, Public:true , Virtual:true }, "Invoke", 
     new JSIL.MethodSignature($.Object, [$.Object, $jsilcore.TypeRef("System.Array", [$.Object])], []), 
     function Invoke (obj, parameters) {
-      var impl = JSIL.$GetMethodImplementation(this);
+      var impl = JSIL.$GetMethodImplementation(this, obj);
 
       if (typeof (impl) !== "function")
         throw new System.Exception("Failed to find constructor");
@@ -837,6 +837,43 @@ JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) {
     }
   );
 
+  $.Method({Static:false, Public:true , Virtual:true }, "MakeGenericMethod", 
+    new JSIL.MethodSignature($jsilcore.TypeRef("System.Reflection.MethodInfo"), [$jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Type")])]),
+    function MakeGenericMethod(typeArguments) {
+      if (this._data.signature.genericArgumentNames.length === 0)
+        throw new System.Exception("Method is not Generic");
+      if (this._data.signature.genericArgumentValues !== undefined)
+        throw new System.Exception("Method is closed Generic");
+
+      var cacheKey = JSIL.HashTypeArgumentArray(typeArguments, this._data.signature.context);
+      var ofCache = this.__OfCache__;
+      if (!ofCache)
+        this.__OfCache__ = ofCache = {};
+
+      var result = ofCache[cacheKey];
+      if (result)
+        return result;
+
+      var parsedTypeName = JSIL.ParseTypeName("System.Reflection.MethodInfo");    
+      var infoType = JSIL.GetTypeInternal(parsedTypeName, $jsilcore, true);
+      var info = JSIL.CreateInstanceOfType(infoType, null);
+      info._typeObject = this._typeObject;
+      info._descriptor = this._descriptor;
+      info.__Attributes__ = this.__Attributes__;
+      info.__Overrides__ = this.__Overrides__;
+
+      info._data = {};
+
+      if (this._data.genericSignature)
+        info._data.genericSignature = this._data.genericSignature;
+
+      var source = this._data.signature;
+      info._data.signature = new JSIL.MethodSignature(source.returnType, source.argumentTypes, source.genericArgumentNames, source.context, source, typeArguments.slice())
+
+      ofCache[cacheKey]  = info;
+      return info;
+    }
+  );
 });
 
 JSIL.ImplementExternals(
@@ -1187,7 +1224,7 @@ JSIL.ImplementExternals("System.Reflection.ConstructorInfo", function ($) {
   $.Method({Static:false, Public:true }, "Invoke", 
     new JSIL.MethodSignature($.Object, [$jsilcore.TypeRef("System.Array", [$.Object])], []), 
     function Invoke (parameters) {
-      var impl = JSIL.$GetMethodImplementation(this);
+      var impl = JSIL.$GetMethodImplementation(this, null);
 
       if (typeof (impl) !== "function")
         throw new System.Exception("Failed to find constructor");
diff --git a/Libraries/JSIL.Core.js b/Libraries/JSIL.Core.js
index dfe624f..01563d0 100644
--- a/Libraries/JSIL.Core.js
+++ b/Libraries/JSIL.Core.js
@@ -6612,7 +6612,7 @@ JSIL.SignatureBase.prototype.LookupMethod = function (context, name) {
 };
 
 
-JSIL.MethodSignature = function (returnType, argumentTypes, genericArgumentNames, context, openSignature) {
+JSIL.MethodSignature = function (returnType, argumentTypes, genericArgumentNames, context, openSignature, genericArgumentValues) {
   this._lastKeyName = "<null>";
   this._lastKey = "<null>";
   this._genericSuffix = null;
@@ -6638,6 +6638,10 @@ JSIL.MethodSignature = function (returnType, argumentTypes, genericArgumentNames
     this.genericArgumentNames = $jsilcore.ArrayNull;
 
   this.openSignature = openSignature || null;
+
+  if (JSIL.IsArray(genericArgumentValues)){
+    this.genericArgumentValues = genericArgumentValues;
+  }
 };
 
 JSIL.MethodSignature.prototype = JSIL.CreatePrototypeObject(JSIL.SignatureBase.prototype);
@@ -9031,7 +9035,7 @@ JSIL.$FilterMethodsByArgumentTypes = function (methods, argumentTypes, returnTyp
   methods.length = l;
 };
 
-JSIL.$GetMethodImplementation = function (method) {
+JSIL.$GetMethodImplementation = function (method, target) {
   var isStatic = method._descriptor.Static;
   var isInterface = method._typeObject.IsInterface;
   var key = isInterface
@@ -9048,7 +9052,12 @@ JSIL.$GetMethodImplementation = function (method) {
       if (!result.signature.IsClosed)
         throw new Error("Generic method is not closed");
   }
-
+  if (method._data.signature.genericArgumentValues) {
+    if (isStatic) {
+       return result.apply(method.DeclaringType.__PublicInterface__, method._data.signature.genericArgumentValues).bind(method.DeclaringType.__PublicInterface__);
+    }
+    return result.apply(target, method._data.signature.genericArgumentValues);
+  }
   return result;
 };
 
diff --git a/Tests/SimpleTestCases/ReflectionGenericMethodInvoke.cs b/Tests/SimpleTestCases/ReflectionGenericMethodInvoke.cs
new file mode 100644
index 0000000..cdf6c8e
--- /dev/null
+++ b/Tests/SimpleTestCases/ReflectionGenericMethodInvoke.cs
@@ -0,0 +1,135 @@
+ï»¿using System;
+using System.Reflection;
+
+public static class Program
+{
+    public static void Main(string[] args)
+    {
+        Console.WriteLine(Class1.GetGenericMethodInfo() == Class2.GetGenericMethodInfo() ? "true" : "false");
+
+        var mi = typeof(Program).GetMethod("StaticGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(null, new object[] { "TestString4" });
+        var actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), null, mi);
+        actionStr("TestString5");
+
+        mi = typeof(Program).GetMethod("StaticGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(null, new object[] { 6 });
+        var actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), null, mi);
+        actionInt(7);
+
+        object obj = new NonGeneric();
+        mi = typeof(NonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(obj, new object[] { "TestString1" });
+        actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), obj, mi);
+        actionStr("TestString2");
+
+        mi = typeof(NonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(obj, new object[] { 3 });
+        actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), obj, mi);
+        actionInt(4);
+
+        obj = new Generic<int>();
+        mi = typeof(Generic<int>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(obj, new object[] { "TestString8" });
+        actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), obj, mi);
+        actionStr("TestString9");
+
+        mi = typeof(Generic<int>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(obj, new object[] { 10 });
+        actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), obj, mi);
+        actionInt(11);
+
+        // TODO: Implement interface method reflection invoke
+        /*obj = new NonGeneric();
+        mi = typeof(INonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(obj, new object[] { "TestString12" });
+        actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), obj, mi);
+        actionStr("TestString13");
+
+        mi = typeof(INonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(obj, new object[] { 14 });
+        actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), obj, mi);
+        actionInt(15);
+
+        obj = new Generic<string>();
+        mi = typeof(INonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(obj, new object[] { "TestString16" });
+        actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), obj, mi);
+        actionStr("TestString17");
+
+        mi = typeof(INonGeneric).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(obj, new object[] { 18 });
+        actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), obj, mi);
+        actionInt(19);
+
+        mi = typeof(IGeneric<string>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+        mi.Invoke(obj, new object[] { "TestString20" });
+        actionStr = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), obj, mi);
+        actionStr("TestString21");
+
+        mi = typeof(IGeneric<string>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(int) });
+        mi.Invoke(obj, new object[] { 22 });
+        actionInt = (Action<int>)Delegate.CreateDelegate(typeof(Action<int>), obj, mi);
+        actionInt(23);*/
+    }
+
+    public static void StaticGenericMethod<T>(T input)
+    {
+        Console.WriteLine(typeof(T).Name);
+        Console.WriteLine(input);
+    }
+}
+
+public interface INonGeneric
+{
+    void InstanceGenericMethod<T>(T input);
+}
+
+public interface IGeneric<TClass>
+{
+    void InstanceGenericMethod<T>(T input);
+}
+
+public class NonGeneric : INonGeneric
+{
+    private readonly string _field = "field";
+
+    public void InstanceGenericMethod<T>(T input)
+    {
+        Console.WriteLine(typeof(T).Name);
+        Console.WriteLine(input);
+        Console.WriteLine(_field);
+    }
+}
+
+public class Generic<TClass> : INonGeneric, IGeneric<TClass>
+{
+    private readonly string _field = "field";
+
+    public void InstanceGenericMethod<T>(T input)
+    {
+        Console.WriteLine(typeof(TClass).Name);
+        Console.WriteLine(typeof(T).Name);
+        Console.WriteLine(input);
+        Console.WriteLine(_field);
+    }
+}
+
+
+
+public static class Class1
+{
+    public static MethodInfo GetGenericMethodInfo()
+    {
+        return typeof(Generic<string>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+    }
+}
+
+public static class Class2
+{
+    public static MethodInfo GetGenericMethodInfo()
+    {
+        return typeof(Generic<string>).GetMethod("InstanceGenericMethod").MakeGenericMethod(new[] { typeof(string) });
+    }
+}
+
diff --git a/Tests/Tests.csproj b/Tests/Tests.csproj
index 6a839ab..c0efe93 100644
--- a/Tests/Tests.csproj
+++ b/Tests/Tests.csproj
@@ -853,6 +853,7 @@
     <None Include="SimpleTestCases\Issue364_1.cs" />
     <None Include="SimpleTestCases\Issue364_2.cs" />
     <None Include="SimpleTestCases\Issue364_3.cs" />
+    <None Include="SimpleTestCases\ReflectionGenericMethodInvoke.cs" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\JSIL\JSIL.csproj">
-- 
1.9.3

