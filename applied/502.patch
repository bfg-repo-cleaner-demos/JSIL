From 5fa2389db6d3e362ea2ca97aaa5885fd28bb54d3 Mon Sep 17 00:00:00 2001
From: ik <igor@kiselev.spb.ru>
Date: Mon, 26 May 2014 02:05:12 -0700
Subject: [PATCH] Fixed reflection for generic method argument/return type.

--HG--
extra : source : a5abbe500739e883846cef82b80f31847ca48747
extra : amend_source : 3a9b3da31436479e45202cc022c002a28b20e55b
---
 Libraries/JSIL.Core.Reflection.js                  |  39 ++++----
 .../ReflectionMethodArgumentTypes.cs               | 109 +++++++++++++++++++++
 Tests/Tests.csproj                                 |   1 +
 3 files changed, 130 insertions(+), 19 deletions(-)
 create mode 100644 Tests/SimpleTestCases/ReflectionMethodArgumentTypes.cs

diff --git a/Libraries/JSIL.Core.Reflection.js b/Libraries/JSIL.Core.Reflection.js
index f0a2ed9..48dd1e6 100644
--- a/Libraries/JSIL.Core.Reflection.js
+++ b/Libraries/JSIL.Core.Reflection.js
@@ -574,6 +574,17 @@ JSIL.ImplementExternals(
 
 JSIL.ImplementExternals(
   "System.Reflection.MethodBase", function ($) {
+    $.RawMethod(false, "InitResolvedSignature",
+      function InitResolvedSignature() {
+        if (this.resolvedSignature === undefined) {
+          this._data.resolvedSignature = this._data.signature.Resolve(this.Name);
+          if (this._data.signature.genericArgumentValues !== undefined) {
+            this._data.resolvedSignature = this._data.resolvedSignature.ResolvePositionalGenericParameters(this._data.signature.genericArgumentValues)
+          }
+        }
+      }
+    );
+  
     $.Method({Static:false, Public:false}, "GetParameterTypes", 
       (new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Type")]), [], [])), 
       function GetParameterTypes () {
@@ -730,21 +741,18 @@ $jsilcore.$MethodGetParameters = function (method) {
 
   if (typeof (result) === "undefined") {
     result = method._cachedParameters = [];
+    method.InitResolvedSignature();
 
-    var argumentTypes = method._data.signature.argumentTypes;
+    var argumentTypes = method._data.resolvedSignature.argumentTypes;
     var parameterInfos = method._data.parameterInfo;
     var tParameterInfo = $jsilcore.System.Reflection.ParameterInfo.__Type__;
 
     if (argumentTypes) {
       for (var i = 0; i < argumentTypes.length; i++) {
-        var argumentType = JSIL.ResolveTypeReference(
-          argumentTypes[i], method._typeObject.__Context__
-        )[1];
-
         var parameterInfo = parameterInfos[i] || null;
 
         // FIXME: Missing non-type information
-        var pi = JSIL.CreateInstanceOfType(tParameterInfo, "$fromArgumentTypeAndPosition", [argumentType, i]);
+        var pi = JSIL.CreateInstanceOfType(tParameterInfo, "$fromArgumentTypeAndPosition", [argumentTypes[i], i]);
         if (parameterInfo)
           pi.$populateWithParameterInfo(parameterInfo);
 
@@ -756,7 +764,7 @@ $jsilcore.$MethodGetParameters = function (method) {
   return result;
 };
 
-JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) {
+JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) { 
   $.Method({Static: false, Public: true }, "GetParameters", 
     (new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Reflection.ParameterInfo")]), [], [])),
     function GetParameters () {
@@ -767,18 +775,10 @@ JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) {
   $.Method({Static:false, Public:true }, "get_ReturnType", 
     (new JSIL.MethodSignature($jsilcore.TypeRef("System.Type"), [], [])), 
     function get_ReturnType () {
-      if (!this._data.signature.returnType)
-        return $jsilcore.System.Void.__Type__;
-
-      var result = this._cachedReturnType;
-
-      if (typeof (result) === "undefined") {
-        result = this._cachedReturnType = JSIL.ResolveTypeReference(
-          this._data.signature.returnType, this._typeObject.__Context__
-        )[1];
-      }
-
-      return result;
+       if (!this._data.signature.returnType)
+        return $jsilcore.System.Void.__Type__;	  
+      this.InitResolvedSignature();
+      return this._data.resolvedSignature.returnType;
     }
   );
 
@@ -868,6 +868,7 @@ JSIL.ImplementExternals("System.Reflection.MethodInfo", function ($) {
       info.__Overrides__ = this.__Overrides__;
 
       info._data = {};
+	  info._data.parameterInfo = this._data.parameterInfo;
 
       if (this._data.genericSignature)
         info._data.genericSignature = this._data.genericSignature;
diff --git a/Tests/SimpleTestCases/ReflectionMethodArgumentTypes.cs b/Tests/SimpleTestCases/ReflectionMethodArgumentTypes.cs
new file mode 100644
index 0000000..5ef4759
--- /dev/null
+++ b/Tests/SimpleTestCases/ReflectionMethodArgumentTypes.cs
@@ -0,0 +1,109 @@
+ï»¿using System;
+using System.Reflection;
+
+public static class Program
+{
+    public static void Main(string[] args)
+    {
+        Write(typeof(Program).GetMethod("StaticGenericMethod").MakeGenericMethod(typeof(A3), typeof(A4)));
+        Write(typeof(Program).GetMethod("StaticNonGenericMethod"));
+
+        Write(typeof(INonGeneric).GetMethod("InstanceGenericMethod1").MakeGenericMethod(typeof(B3), typeof(B4)));
+        Write(typeof(INonGeneric).GetMethod("InstanceNonGenericMethod1"));
+
+        Write(typeof(NonGeneric).GetMethod("InstanceGenericMethod1").MakeGenericMethod(typeof(B3), typeof(B4)));
+        Write(typeof(NonGeneric).GetMethod("InstanceNonGenericMethod1"));
+
+        Write(typeof(IGeneric<Q>).GetMethod("InstanceGenericMethod2").MakeGenericMethod(typeof(C3), typeof(C4)));
+        Write(typeof(IGeneric<Q>).GetMethod("InstanceNonGenericMethod2"));
+
+        Write(typeof(Generic<Q>).GetMethod("InstanceGenericMethod1").MakeGenericMethod(typeof(C3), typeof(C4)));
+        Write(typeof(Generic<Q>).GetMethod("InstanceNonGenericMethod1"));
+        Write(typeof(Generic<Q>).GetMethod("InstanceGenericMethod2").MakeGenericMethod(typeof(C3), typeof(C4)));
+        Write(typeof(Generic<Q>).GetMethod("InstanceNonGenericMethod2"));
+    }
+
+    public static void Write(MethodInfo mi)
+    {
+        Console.WriteLine(mi.ReturnType.Name);
+        foreach (var parameterInfo in mi.GetParameters())
+        {
+            Console.WriteLine(parameterInfo.ParameterType.Name);
+        }
+    }
+
+    public static T1 StaticGenericMethod<T1, T2>(T2 input, A1 input2)
+    {
+        return default(T1);
+    }
+
+    public static A1 StaticNonGenericMethod(A2 input)
+    {
+        return null;
+    }
+}
+
+public interface INonGeneric
+{
+    T2 InstanceGenericMethod1<T1, T2>(T1 input, B1 input2);
+    B2 InstanceNonGenericMethod1(B1 input2);
+}
+
+public interface IGeneric<TClass>
+{
+    T2 InstanceGenericMethod2<T1, T2>(TClass input0, T1 input, C1 input2);
+    C2 InstanceNonGenericMethod2(TClass input, C1 input2);
+}
+
+public class NonGeneric : INonGeneric
+{
+    public T2 InstanceGenericMethod1<T1, T2>(T1 input, B1 input2)
+    {
+        return default(T2);
+    }
+
+    public B2 InstanceNonGenericMethod1(B1 input2)
+    {
+        return null;
+    }
+}
+
+public class Generic<TClass> : INonGeneric, IGeneric<TClass>
+{
+    public T2 InstanceGenericMethod1<T1, T2>(T1 input, B1 input2)
+    {
+        return default(T2);
+    }
+
+    public B2 InstanceNonGenericMethod1(B1 input2)
+    {
+        return null;
+    }
+
+    public T2 InstanceGenericMethod2<T1, T2>(TClass input0, T1 input, C1 input2)
+    {
+        return default(T2);
+    }
+
+    public C2 InstanceNonGenericMethod2(TClass input, C1 input2)
+    {
+        return null;
+    }
+}
+
+public class Q { }
+
+public class A1 { }
+public class A2 { }
+public class A3 { }
+public class A4 { }
+
+public class B1 { }
+public class B2 { }
+public class B3 { }
+public class B4 { }
+
+public class C1 { }
+public class C2 { }
+public class C3 { }
+public class C4 { }
\ No newline at end of file
diff --git a/Tests/Tests.csproj b/Tests/Tests.csproj
index a9ec91c..b4304be 100644
--- a/Tests/Tests.csproj
+++ b/Tests/Tests.csproj
@@ -858,6 +858,7 @@
     <None Include="SimpleTestCases\ReflectionTypeGenericInfo.cs" />
     <None Include="SimpleTestCases\InterfaceGenericCallWithGenericParameter_Issue348.cs" />
     <None Include="SimpleTestCases\ReflectionGenericMethodInvoke.cs" />
+    <None Include="SimpleTestCases\ReflectionMethodArgumentTypes" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\JSIL\JSIL.csproj">
-- 
1.9.3

