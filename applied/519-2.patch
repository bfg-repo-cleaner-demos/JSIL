From 1e51d70ceddca4af8eef7e97f951791f75747262 Mon Sep 17 00:00:00 2001
From: ik <igor@kiselev.spb.ru>
Date: Sun, 25 May 2014 22:36:40 -0700
Subject: [PATCH 1/2] Extract method/field info for expression trees.

--HG--
extra : source : d1f6f96286feaf8e5138d829c931e9b63d65c268
---
 JSIL/AST/JSExpressionTypes.cs                      | 25 ++++++++++
 JSIL/AST/JSIdentifierTypes.cs                      |  8 +++
 JSIL/ILBlockTranslator.cs                          |  8 ++-
 JSIL/JavascriptAstEmitter.cs                       | 57 ++++++++++++++++++++++
 JSIL/Transforms/CacheSignatures.cs                 |  5 ++
 .../StaticAnalysis/EmulateStructAssignment.cs      |  1 +
 Libraries/JSIL.Bootstrap.Linq.js                   | 20 +++++++-
 Libraries/JSIL.Core.js                             | 31 ++++++++++++
 Proxies/BCL/JSIL.Bootstrap.Linq.cs                 | 18 +++++++
 Proxies/Reflection.cs                              |  6 +++
 10 files changed, 175 insertions(+), 4 deletions(-)

diff --git a/JSIL/AST/JSExpressionTypes.cs b/JSIL/AST/JSExpressionTypes.cs
index d6a2a6e..394415f 100644
--- a/JSIL/AST/JSExpressionTypes.cs
+++ b/JSIL/AST/JSExpressionTypes.cs
@@ -757,6 +757,31 @@ public JSCachedTypeOfExpression (TypeReference type, int index)
         }
     }
 
+    public class JSMethodOfExpression : JSMethod
+    {
+        public JSMethodOfExpression(MethodReference reference, MethodInfo method, MethodTypeFactory methodTypes,
+            IEnumerable<TypeReference> genericArguments = null)
+            : base(reference, method, methodTypes, genericArguments)
+        {
+        }
+
+        public override bool HasGlobalStateDependency
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        public override bool IsConstant
+        {
+            get
+            {
+                return true;
+            }
+        }
+    }
+
     public class JSPublicInterfaceOfExpression : JSExpression {
         public JSPublicInterfaceOfExpression (JSExpression inner)
             : base(inner) {
diff --git a/JSIL/AST/JSIdentifierTypes.cs b/JSIL/AST/JSIdentifierTypes.cs
index d3217ad..f595e69 100644
--- a/JSIL/AST/JSIdentifierTypes.cs
+++ b/JSIL/AST/JSIdentifierTypes.cs
@@ -214,6 +214,14 @@ public class JSField : JSIdentifier {
         }
     }
 
+    public class JSFieldOfExpression : JSField
+    {
+        public JSFieldOfExpression(FieldReference reference, FieldInfo field)
+            : base(reference, field)
+        {
+        }
+    }
+
     public class JSProperty : JSIdentifier {
         public readonly MemberReference Reference;
         public readonly PropertyInfo Property;
diff --git a/JSIL/ILBlockTranslator.cs b/JSIL/ILBlockTranslator.cs
index 5a634b5..8cf4977 100644
--- a/JSIL/ILBlockTranslator.cs
+++ b/JSIL/ILBlockTranslator.cs
@@ -533,6 +533,10 @@ TypeReference resultType
             switch (method.Method.Member.FullName) {
                 // Doing this replacement here enables more elimination of temporary variables
                 case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":
+                case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle)":
+                case "System.Reflection.MethodBase System.Reflection.MethodBase::GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)":
+                case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":
+                case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)":
                     return arguments.First();
 
                 case "T JSIL.Builtins::CreateNamedFunction(System.String,System.String[],System.String,System.Object)":
@@ -2911,12 +2915,12 @@ TypeReference resultType
 
         protected JSExpression Translate_Ldtoken (ILExpression node, MethodReference method) {
             var methodInfo = GetMethod(method);
-            return new JSMethod(method, methodInfo, MethodTypes);
+            return new JSMethodOfExpression(method, methodInfo, MethodTypes);
         }
 
         protected JSExpression Translate_Ldtoken (ILExpression node, FieldReference field) {
             var fieldInfo = GetField(field);
-            return new JSField(field, fieldInfo);
+            return new JSFieldOfExpression(field, fieldInfo);
         }
 
         public static bool NeedsExplicitThis (
diff --git a/JSIL/JavascriptAstEmitter.cs b/JSIL/JavascriptAstEmitter.cs
index 4e32df8..fa366b5 100644
--- a/JSIL/JavascriptAstEmitter.cs
+++ b/JSIL/JavascriptAstEmitter.cs
@@ -942,6 +942,63 @@ Configuration configuration
             }
         }
 
+        public void VisitNode(JSMethodOfExpression moe)
+        {
+            var methodName = Util.EscapeIdentifier(moe.Method.GetName(true), EscapingMode.MemberIdentifier);
+
+            Output.WriteRaw("JSIL.GetMethodInfo");
+            Output.LPar();
+
+            Output.Identifier(
+                moe.Reference.DeclaringType, ReferenceContext, IncludeTypeParens.Peek()
+            );
+            Output.Comma();
+
+            Output.WriteRaw("\"");
+            Output.Identifier(methodName);
+            Output.WriteRaw("\"");
+            Output.Comma();
+
+            SignatureCacher.WriteSignatureToOutput(
+                Output, Stack.OfType<JSFunctionExpression>().FirstOrDefault(),
+                moe.Reference, moe.Method.Signature, ReferenceContext, false
+            );
+            Output.Comma();
+
+            Output.Value(moe.Method.IsStatic);
+
+            if (moe.GenericArguments != null && moe.GenericArguments.Any())
+            {
+                Output.Comma();
+                Output.OpenBracket();
+                Output.CommaSeparatedList(moe.GenericArguments, ReferenceContext);
+                Output.CloseBracket();
+            }
+
+            Output.RPar();
+        }
+
+        public void VisitNode(JSFieldOfExpression moe)
+        {
+            var fieldName = Util.EscapeIdentifier(moe.Field.ChangedName ?? moe.Field.Name, EscapingMode.MemberIdentifier);
+
+            Output.WriteRaw("JSIL.GetFieldInfo");
+            Output.LPar();
+
+            Output.Identifier(
+                moe.Reference.DeclaringType, ReferenceContext, IncludeTypeParens.Peek()
+            );
+            Output.Comma();
+
+            Output.WriteRaw("\"");
+            Output.Identifier(fieldName);
+            Output.WriteRaw("\"");
+            Output.Comma();
+
+            Output.Value(moe.Field.IsStatic);
+
+            Output.RPar();
+        }
         public void VisitNode (JSPublicInterfaceOfExpression poe) {
             VisitChildren(poe);
 
diff --git a/JSIL/Transforms/CacheSignatures.cs b/JSIL/Transforms/CacheSignatures.cs
index e32cf5f..31a2071 100644
--- a/JSIL/Transforms/CacheSignatures.cs
+++ b/JSIL/Transforms/CacheSignatures.cs
@@ -253,6 +253,11 @@ public class CacheSet {
             }
         }
 
+        public void VisitNode(JSMethodOfExpression methodOf)
+        {
+            CacheSignature(methodOf.Reference, methodOf.Method.Signature, false);
+        }
+
         public void VisitNode (JSInvocationExpression invocation) {
             var jsm = invocation.JSMethod;
             MethodInfo method = null;
diff --git a/JSIL/Transforms/StaticAnalysis/EmulateStructAssignment.cs b/JSIL/Transforms/StaticAnalysis/EmulateStructAssignment.cs
index 8b036a6..3118b06 100644
--- a/JSIL/Transforms/StaticAnalysis/EmulateStructAssignment.cs
+++ b/JSIL/Transforms/StaticAnalysis/EmulateStructAssignment.cs
@@ -155,6 +155,7 @@ bool optimizeCopies
                 (value is JSPassByReferenceExpression) ||
                 (value is JSNewBoxedVariable) ||
                 (value is JSDefaultValueLiteral) ||
+                (value is JSFieldOfExpression) ||
                 ((iae != null) && ((iae.Target is JSNewExpression) || (iae.Target is JSDefaultValueLiteral)))
             ) {
                 return false;
diff --git a/Libraries/JSIL.Bootstrap.Linq.js b/Libraries/JSIL.Bootstrap.Linq.js
index 3d7762e..510d6c5 100644
--- a/Libraries/JSIL.Bootstrap.Linq.js
+++ b/Libraries/JSIL.Bootstrap.Linq.js
@@ -722,8 +722,24 @@ JSIL.ImplementExternals("System.Linq.Expressions.ParameterExpression", function
         $.Boolean
       ], []), 
     function Make (type, name, isByRef) {
-      // FIXME
-      return new System.Linq.Expressions.ParameterExpression(name);
+      var experession = new System.Linq.Expressions.ParameterExpression(name);
+      experession._type = type;
+      experession._isByRef = isByRef;
+      return experession;
+    }
+  );
+
+  $.Method({Static:false , Public:true}, "get_Type", 
+    new JSIL.MethodSignature($jsilcore.TypeRef("System.Type"), [], []), 
+    function get_Type() {
+      return this._type;
+    }
+  );
+  
+  $.Method({Static:false , Public:true}, "get_IsByRef", 
+    new JSIL.MethodSignature($jsilcore.TypeRef("System.Boolean"), [], []), 
+    function get_IsByRef() {
+      return this._isByRef;
     }
   );
 });
diff --git a/Libraries/JSIL.Core.js b/Libraries/JSIL.Core.js
index 6751b6c..fb48ec1 100644
--- a/Libraries/JSIL.Core.js
+++ b/Libraries/JSIL.Core.js
@@ -9428,4 +9428,35 @@ JSIL.ValidateArgumentTypes = function (types) {
       JSIL.RuntimeError("Argument type list must only contain type objects: " + JSON.stringify(item));
     }
   }
+};
+
+JSIL.GetMethodInfo = function(typeObject, name, signature, isStatic, methodGenericParameters){
+  var methods = JSIL.GetMembersInternal(
+    typeObject.__Type__, $jsilcore.BindingFlags.$Flags("DeclaredOnly", "Public", "NonPublic", isStatic ? "Static" : "Instance"), "$AllMethods", name
+  );
+  for (var i = 0, l = methods.length; i < l; i++) {
+    var method = methods[i];
+
+    if (method._data.signature.Hash == signature.Hash){
+      if (JSIL.IsArray(methodGenericParameters)) {
+        var genericParameterTypes = [];
+        for (var i = 0, l = methodGenericParameters.length; i < l; i++) {
+          genericParameterTypes.push(methodGenericParameters[i].get().__Type__);
+        }
+        return method.MakeGenericMethod(genericParameterTypes);
+      }
+      return method;
+    }
+  }
+  return null; 
+};
+
+JSIL.GetFieldInfo = function(typeObject, name, isStatic){
+  var fields = JSIL.GetMembersInternal(
+    typeObject.__Type__, $jsilcore.BindingFlags.$Flags("DeclaredOnly", "Public", "NonPublic", isStatic ? "Static" : "Instance"), "FieldInfo", name
+  );
+  if (fields.length == 1) {
+    return fields[0]; 
+  }
+  return null;
 };
\ No newline at end of file
diff --git a/Proxies/BCL/JSIL.Bootstrap.Linq.cs b/Proxies/BCL/JSIL.Bootstrap.Linq.cs
index d6bf8a9..7106085 100644
--- a/Proxies/BCL/JSIL.Bootstrap.Linq.cs
+++ b/Proxies/BCL/JSIL.Bootstrap.Linq.cs
@@ -216,5 +216,23 @@ private static ParameterExpression Make(Type type, string name, bool flag)
         {
             throw new NotImplementedException();
         }
+
+        public override Type Type
+        {
+            [JSExternal]
+            get
+            {
+                throw new NotImplementedException();
+            }
+        }
+
+        public bool IsByRef
+        {
+            [JSExternal]
+            get
+            {
+                throw new NotImplementedException();
+            }
+        }
     }
 }
diff --git a/Proxies/Reflection.cs b/Proxies/Reflection.cs
index fcf8b8d..0b8075a 100644
--- a/Proxies/Reflection.cs
+++ b/Proxies/Reflection.cs
@@ -40,6 +40,12 @@ public abstract class TypeProxy {
         public static Type GetType (string typeName, bool throwOnFail, bool ignoreCase) {
             throw new NotImplementedException();
         }
+
+        [JSReplacement("$this === $other")]
+        public virtual bool IsEquivalentTo(Type other)
+        {
+            throw new NotImplementedException();
+        }
     }
 
     [JSProxy(
-- 
1.9.3


From 781f4d1e71b7ab2f2179b980e419e8f19f680122 Mon Sep 17 00:00:00 2001
From: ik <igor@kiselev.spb.ru>
Date: Mon, 2 Jun 2014 20:51:20 -0700
Subject: [PATCH 2/2] Test added for extracting method info from Expression.

--HG--
extra : source : 0066fc1f9067cb5db7866daa768c787e32910fb0
---
 .../ExpressionsTest.cs                             | 126 +++++++++++++++++++++
 Tests/Tests.csproj                                 |   1 +
 2 files changed, 127 insertions(+)
 create mode 100644 Tests/SimpleTestCasesForTranslatedBcl/ExpressionsTest.cs

diff --git a/Tests/SimpleTestCasesForTranslatedBcl/ExpressionsTest.cs b/Tests/SimpleTestCasesForTranslatedBcl/ExpressionsTest.cs
new file mode 100644
index 0000000..f6d12cc
--- /dev/null
+++ b/Tests/SimpleTestCasesForTranslatedBcl/ExpressionsTest.cs
@@ -0,0 +1,126 @@
+﻿using System;
+using System.Linq.Expressions;
+using System.Reflection;
+
+public static class Program
+{
+    public static A Field;
+
+    public static void Main(string[] args)
+    {
+        WriteMethod(() => StaticMethodNonGeneric());
+        WriteMethod(() => StaticMethodGeneric<A>());
+
+        WriteMethod((NonGenericClass nonGenericClass) => nonGenericClass.InstanceNonGenericMethod());
+        WriteMethod((NonGenericClass nonGenericClass) => nonGenericClass.InstanceGenericMethod<A>());
+
+        WriteMethod((INonGenericInterface interfaceInstance) => interfaceInstance.InstanceNonGenericMethod());
+        WriteMethod((INonGenericInterface interfaceInstance) => interfaceInstance.InstanceGenericMethod<A>());
+
+        WriteMethod((GenericClass<B> genericClass) => genericClass.InstanceNonGenericMethod());
+        WriteMethod((GenericClass<B> genericClass) => genericClass.InstanceGenericMethod<A>());
+
+        WriteMethod((IGenericInterface<B> interfaceGenericInstance) => interfaceGenericInstance.InstanceNonGenericMethod());
+        WriteMethod((IGenericInterface<B> interfaceGenericInstance) => interfaceGenericInstance.InstanceGenericMethod<A>());
+
+        WriteField(() => Field);
+        WriteField((NonGenericClass nonGenericClass) => nonGenericClass.FieldOfNonGenericClass);
+        WriteField((GenericClass<B> genericClass) => genericClass.FieldOfNonGenericClass1);
+        WriteField((GenericClass<B> genericClass) => genericClass.FieldOfNonGenericClass2);
+    }
+
+    public static void StaticMethodNonGeneric()
+    { }
+
+    public static T StaticMethodGeneric<T>()
+    {
+        return default(T);
+    }
+
+    private static void WriteMethod(Expression<Action> expression)
+    {
+        WriteMethodInternal(expression);
+    }
+
+    private static void WriteMethod<T>(Expression<Action<T>> expression)
+    {
+        WriteMethodInternal(expression);
+    }
+
+    private static void WriteMethodInternal(LambdaExpression expression)
+    {
+        var mi = ExtractMethodInfo(expression);
+        Console.WriteLine("{2} {0}.{1}(...)", mi.DeclaringType.Name, mi.Name, mi.ReturnType.Name);
+    }
+
+    private static void WriteField<TField>(Expression<Func<TField>> expression)
+    {
+        WriteFieldInternal(expression);
+    }
+
+    private static void WriteField<TInput, TField>(Expression<Func<TInput, TField>> expression)
+    {
+        WriteFieldInternal(expression);
+    }
+
+    private static void WriteFieldInternal(LambdaExpression expression)
+    {
+        var mi = ExtractFieldInfo(expression);
+        Console.WriteLine("{2} {0}.{1}", mi.DeclaringType.Name, mi.Name, mi.FieldType.Name);
+    }
+
+    private static MethodInfo ExtractMethodInfo(LambdaExpression expression)
+    {
+        return ((MethodCallExpression)(expression.Body)).Method;
+    }
+
+    private static FieldInfo ExtractFieldInfo(LambdaExpression expression)
+    {
+        return (FieldInfo)((MemberExpression)(expression.Body)).Member;
+    }
+}
+
+public interface INonGenericInterface
+{
+    void InstanceNonGenericMethod();
+    T InstanceGenericMethod<T>();
+}
+
+public class NonGenericClass : INonGenericInterface
+{
+    public A FieldOfNonGenericClass;
+
+    public void InstanceNonGenericMethod()
+    {
+    }
+
+    public T InstanceGenericMethod<T>()
+    {
+        return default(T);
+    }
+}
+
+public interface IGenericInterface<T>
+{
+    T InstanceNonGenericMethod();
+    T2 InstanceGenericMethod<T2>();
+}
+
+public class GenericClass<T> : IGenericInterface<T>
+{
+    public A FieldOfNonGenericClass1;
+    public T FieldOfNonGenericClass2;
+
+    public T InstanceNonGenericMethod()
+    {
+        return default(T);
+    }
+
+    public T2 InstanceGenericMethod<T2>()
+    {
+        return default(T2);
+    }
+}
+
+public class A { }
+public class B { }
\ No newline at end of file
diff --git a/Tests/Tests.csproj b/Tests/Tests.csproj
index 158a242..20f2212 100644
--- a/Tests/Tests.csproj
+++ b/Tests/Tests.csproj
@@ -830,6 +830,7 @@
     <None Include="IOTestCases\BasicStreamNavigation.cs" />
     <Compile Include="TestUtil.cs" />
     <Compile Include="VerbatimTests.cs" />
+    <None Include="SimpleTestCasesForTranslatedBcl\ExpressionsTest.cs" />
     <None Include="SimpleTestCases\ObjectExpression_Enumerable.fs" />
     <None Include="InterfaceTestCases\InterfaceColliding.cs" />
     <None Include="InterfaceTestCases\InterfaceCollidingImplicit.cs" />
-- 
1.9.3

